---
layout:     post
title:      "Redis 学习笔记 - 集群"
date:       2018-04-25
author:     "余修忞(xueyufish)"
keyword:    "Redis, 缓存, 分布式缓存, 集群, 余修忞, yuxiumin, xueyufish"
tags:
    - Redis
    - 缓存
---

Redis Cluster 是 Redis 的分布式解决方案，在 3.0 版本正式推出，有效地解决了 Redis 分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用 Cluster 架构方案达到负载均衡的目的。

在 Redis Cluster 之前，Redis 分布式方案一般有两种：
* 客户端分区方案，优点是分区逻辑可控，缺点是需要自己处理数据路由、高可用、故障转移等问题;
* 代理方案，优点是简化客户端分布式逻辑和升级维护便利，缺点是加重架构部署复杂度和性能损耗;

## 数据分布
### 数据分布理论
分布式数据库首先要解决把整个数据集按照分区规则映射到多个节点的问题，即把数据集划分到多个节点上，每个节点负责整体数据的一个子集。常见的分区规则有哈希分区和顺序分区两种：
* **哈希分区**：离散度好、数据分布业务无关、无法顺序访问，代表产品 Redis Cluster、Cassandra、Dynamo;
* **顺序分区**：离散度易倾斜、数据分布业务相关、可顺序访问，代表产品 Bigtable、HBase、Hypertable;

由于 Redis Cluster 采用哈希分区规则，这里重点讨论哈希分区，常见的哈希分区规则有几种，下面分别介绍：
* **节点取余分区**：使用特定的数据，如 Redis 的键或用户 ID，再根据节点数量 N 使用公式：<code>hash（key）% N</code> 计算出哈希值，用来决定数据映射到哪一个节点上。这种方案存在的问题是当节点数量变化时(如扩容或收缩节点)，数据节点映射关系需要重新计算，会导致数据的重新迁移。优点是简单性，常用于数据库的分库分表规则，一般采用预分区的方式，提前根据数据量规划好分区数，比如划分为 512 或 1024 张表，保证可支撑未来一段时间的数据量，再根据负载情况将表迁移到其他数据库中。扩容时通常采用翻倍扩容，避免数据映射全部被打乱导致全量迁移的情况。
* **一致性哈希分区**：一致性哈希分区 (Distributed Hash Table) 实现思路是为系统中每个节点分配一个 token，范围一般在 0~2^32，这些 token 构成一个哈希环。数据读写执行节点查找操作时，先根据 key 计算 hash 值，然后顺时针找到第一个大于等于该哈希值的 token 节点。这种方式相比节点取余最大的好处在于加入和删除节点只影响哈希环中相邻的节点，对其他节点无影响。但一致性哈希分区存在几个问题：
  - 加减节点会造成哈希环中部分数据无法命中，需要手动处理或者忽略这部分数据，因此一致性哈希常用于缓存场景。
  - 当使用少量节点时，节点变化将大范围影响哈希环中数据映射，因此这种方式不适合少量数据节点的分布式方案。
  - 普通的一致性哈希分区在增减节点时需要增加一倍或减去一半节点才能保证数据和负载的均衡。
* **虚拟槽分区**: 虚拟槽分区巧妙地使用了哈希空间，使用分散度良好的哈希函数把所有数据映射到一个固定范围的整数集合中，整数定义为槽（slot）。这个范围一般远远大于节点数，比如 Redis Cluster 槽范围是 0~16384。槽是集群内数据管理和迁移的基本单位，采用大范围槽的主要目的是为了方便数据拆分和集群扩展。每个节点会负责一定数量的槽。

### Redis 数据分区
Redis Cluser 采用虚拟槽分区，所有的键根据哈希函数映射到 0~16384 整数槽内，计算公式为：<code>slot=CRC16（key）& 16383</code>。每一个节点负责维护一部分槽以及槽所映射的键值数据。Redis虚拟槽分区具有以下特点：
* 解耦数据和节点之间的关系，简化了节点扩容和收缩难度；
* 节点自身维护槽的映射关系，不需要客户端或者代理服务维护槽分区元数据；
* 支持节点、槽、键之间的映射查询，用于数据路由、在线伸缩等场景；

### 集群功能限制
Redis 集群相对单机在功能上存在一些限制，需要提前了解，在使用时做好规避。限制如下：
1. key 批量操作支持有限。如 mset、mget，目前只支持具有相同 slot 值的 key 执行批量操作。对于映射为不同 slot 值的 key 由于执行 mget、mget 等操作可能存在于多个节点上因此不被支持。
2. key 事务操作支持有限。同理只支持多 key 在同一节点上的事务操作，当多个 key 分布在不同的节点上时无法使用事务功能。
3. key 作为数据分区的最小粒度，因此不能将一个大的键值对象如 hash、list 等映射到不同的节点。
4. 不支持多数据库空间。单机下的 Redis 可以支持 16 个数据库，集群模式下只能使用一个数据库空间，即db0。
5. 复制结构只支持一层，从节点只能复制主节点，不支持嵌套树状复制结构。

## 节点通信
### 通信流程
在分布式存储中需要提供维护节点元数据信息的机制，所谓元数据是指：节点负责哪些数据，是否出现故障等状态信息。常见的元数据维护方式分为：集中式和 P2P 方式。Redis集群采用 P2P 的 Gossip 协议，Gossip 协议工作原理就是节点彼此不断通信交换信息，一段时间后所有的节点都会知道集群完整的信息，这种方式类似流言传播。通信过程如下：
1. 集群中的每个节点都会单独开辟一个 TCP 通道，用于节点之间彼此通信，通信端口号在基础端口上加 10000;
2. 每个节点在固定周期内通过特定规则选择几个节点发送 ping 消息;
3. 接收到 ping 消息的节点用 pong 消息作为响应;

集群中每个节点通过一定规则挑选要通信的节点，每个节点可能知道全部节点，也可能仅知道部分节点，只要这些节点彼此可以正常通信，最终它们会达到一致的状态。当节点出故障、新节点加入、主从角色变化、槽信息变更等事件发生时，通过不断的 ping/pong 消息通信，经过一段时间后所有的节点都会知道整个集群全部节点的最新状态，从而达到集群状态同步的目的。

### Gossip消息
Gossip 协议的主要职责就是信息交换，信息交换的载体就是节点彼此发送的 Gossip 消息，常用的Gossip消息可分为：ping消息、pong消息、meet消息、fail消息等；
* meet 消息：用于通知新节点加入。消息发送者通知接收者加入到当前集群，meet 消息通信正常完成后，接收节点会加入到集群中并进行周期性的 ping、pong 消息交换。
* ping 消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送 ping 消息，用于检测节点是否在线和交换彼此状态信息。ping 消息发送封装了自身节点和部分其他节点的状态数据。
* pong 消息：当接收到 ping、meet 消息时，作为响应消息回复给发送方确认消息正常通信。pong 消息内部封装了自身状态数据, 节点也可以向集群内广播自身的 pong 消息来通知整个集群对自身状态进行更新。
* fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个 fail 消息，其他节点接收到 fail 消息之后把对应节点更新为下线状态。

## 集群伸缩

Redis 集群伸缩可以简单理解为槽和数据在节点之间的移动，主要包括：

### 集群扩容

Redis集群扩容操作可分为如下步骤：
1. 准备新节点: 准备好新节点并运行在集群模式下，新节点跟集群内的节点配置保持一致。启动后的新节点作为孤儿节点运行，并没有其他节点与之通信；
2. 加入集群: 新节点采用 cluster meet 命令加入到现有集群中，集群内新旧节点经过一段时间的 ping/pong 消息通信之后，所有节点会发现新节点并将它们的状态保存到本地。新节点刚开始都是主节点状态，但是由于没有负责的槽，所以不能接受任何读写操作。
3. 迁移槽和数据:






## 参考资料

[Redis cluster tutorial](https://redis.io/topics/cluster-tutorial)

[Redis开发与运维](https://book.douban.com/subject/26971561/)
