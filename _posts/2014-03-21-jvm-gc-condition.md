---
layout:     post
title:      "JVM 垃圾收集 - 对象可回收判断"
keyword:    "Java, JVM, GC"
date:       2014-03-21
author:     "余修忞(xueyufish)"
tags:
    - Java
---

在 JVM 内存模型<sup>[1]</sup> 中， 程序计数器、虚拟机栈和本地方法栈这三个区域属于线程私有的，只存在于线程的生命周期内，线程结束之后也会消失，因此不需要对这三个区域进行垃圾回收。垃圾回收主要是针对 Java 堆和方法区进行。

### 引用计数

给对象添加一个引用计数器，当对象增加一个引用时计数器加 1，引用失效时计数器减 1。引用计数为 0 的对象可被回收。当两个对象出现循环引用时，引用计数器永远不为 0，会导致 GC 收集器无法回收。

```java
objA.instance = objB;
objB.instance = objA;
```

### 可达性

通过 GC Roots 作为起始点进行搜索，能够到达到的对象都是都是可用的，不可达的对象可被回收。

**GC Roots 一般包含以下内容**：

1. 虚拟机栈中引用的对象（本地变量表）
2. 方法区中类静态属性引用的对象
3. 方法区中的常量引用的对象
4. 本地方法栈中引用的对象（Native对象） 

### 引用类型

无论是通过引用计算算法判断对象的引用数量，还是通过可达性分析算法判断对象的引用链是否可达，判定对象是否存活都与“引用”有关。Java 对引用的概念进行了扩充，引入四种强度不同的引用类型：

**强引用**

只要强引用存在，垃圾回收器永远不会回收调掉被引用的对象。使用 new 一个新对象的方式来创建强引用。
```java
Object obj = new Object();
```

**软引用**

使用 SoftReference 类来实现，用来描述一些还有用但是并非必需的对象。在系统将要发生内存溢出异常之前，将会对这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出溢出异常。

软引用主要用来实现类似缓存的功能，在内存足够的情况下直接通过软引用取值；当内存不足时，自动删除这部分缓存数据，从真正的来源获取这些数据。
```java
Object obj = new Object();
SoftReference<Object> sf = new SoftReference<Object>(obj);
```

**弱引用**

使用 WeakReference 类来实现，只能生存到下一次垃圾收集发生之前，当垃圾收集器工作时，无论当前内存是否足够，都会被回收。
```java
Object obj = new Object();
WeakReference<Object> wf = new WeakReference<Object>(obj);
```

**虚引用**

使用 PhantomReference 来实现，又称为幽灵引用或者幻影引用。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。
```java
Object obj = new Object();
PhantomReference<Object> pf = new PhantomReference<Object>(obj);
```

### 方法区的回收

方法区主要存放永久代对象，而永久代对象的回收率比新生代差很多，因此在方法区上进行回收性价比不高。在方法区主要是对常量池的回收和对类的卸载。常量池的回收和堆中对象回收类似。类的卸载条件很多，需要满足以下三个条件，并且满足了也不一定会被卸载：

1. 该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。
2. 加载该类的 ClassLoader 已经被回收。
3. 该类对应的 java.lang.Class 对象没有在任何地方被引用，也就无法在任何地方通过反射访问该类方法。

可以通过 -Xnoclassgc 参数来控制是否对类进行卸载。在大量使用反射、动态代理、CGLib 等 ByteCode 框架、动态生成 JSP 以及 OSGI 这类频繁自定义 ClassLoader 的场景都需要虚拟机具备类卸载功能，以保证不会出现内存溢出。

### finalize()

finalize() 类似 C++ 的析构函数，用来做关闭外部资源等工作。但是 try-finally 等方式可以做的更好，并且该方法运行代价高昂，不确定性大，无法保证各个对象的调用顺序，因此最好不要使用。当一个对象可被回收时，如果需要执行该对象的 finalize() 方法，那么就有可能通过在该方法中让对象重新被引用，从而实现自救。
