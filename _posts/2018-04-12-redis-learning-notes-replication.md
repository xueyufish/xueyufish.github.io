---
layout:     post
title:      "Redis 学习笔记 - 复制"
date:       2018-04-12
author:     "xueyufish"
keyword:    "Redis, 缓存, 分布式缓存, 复制, xueyufish"
description: "Redis 复制学习笔记"
tags:
    - Redis
    - 缓存
---

在分布式系统中为了解决单点问题，通常会把数据复制多个副本部署到其他机器，满足故障恢复和负载均衡等需求, Redis也是如此，它为我们提供了复制功能，实现了相同数据的多个 Redis 副本。复制功能是高可用 Redis 的基础，后面章节的哨兵和集群都是在复制的基础上实现高可用的。

# 配置
## 建立复制
参与复制的 Redis 实例划分为主节点 (master) 和从节点 (slave)。默认情况下，Redis 都是主节点。每个从节点只能有一个主节点，而主节点可以同时具有多个从节点。复制的数据流是单向的，只能由主节点复制到从节点。配置复制的方式有以下三种：
1. 在配置文件中加入 <code>slaveof {masterHost} {masterPort}</code> 随Redis启动生效。
2. 在 redis-server 启动命令后加入 <code>-- slaveof {masterHost} {masterPort}</code> 生效。
3. 直接使用命令：<code>slaveof {masterHost} {masterPort}</code> 生效。

主从节点复制成功建立后，可以使用 <code>info replication</code> 命令查看复制相关状态

## 断开复制
slaveof 命令不但可以建立复制，还可以在从节点执行 <code>slaveof no one</code> 来断开与主节点复制关系。断开复制主要流程如下：
1. 断开与主节点复制关系；
2. 从节点晋升为主节点；

从节点断开复制后并不会抛弃原有数据，只是无法再获取主节点上的数据变化。

通过 slaveof 命令还可以实现切主操作(把当前从节点对主节点的复制切换到另一个主节点)。执行 <code>slaveof {newMasterIp} {newMasterPort}</code> 命令即可，切主操作流程如下：
1. 断开与旧主节点复制关系。
2. 与新主节点建立复制关系。
3. 删除从节点当前所有数据。
4. 对新主节点进行复制操作。

## 只读性
默认情况下，从节点使用 <code>slave-read-only=yes</code> 配置为只读模式。

由于复制只能从主节点到从节点，对于从节点的任何修改主节点都无法感知，修改从节点会造成主从数据不一致，因此建议线上不要修改从节点的只读模式。

## 传输延迟
主从节点一般部署在不同机器上，复制时的网络延迟就成为需要考虑的问题，Redis 为我们提供了repl-disable-tcp-nodelay 参数用于控制是否关闭 TCP_NODELAY，默认关闭，说明如下：
* 当关闭时，主节点产生的命令数据无论大小都会及时地发送给从节点，这样主从之间延迟会变小，但增加了网络带宽的消耗。适用于主从之间的网络环境良好的场景，如同机架或同机房部署。
* 当开启时，主节点会合并较小的 TCP 数据包从而节省带宽，默认发送时间间隔取决于 Linux 的内核，一般默认为 40 毫秒。这种配置节省了带宽但增大主从之间的延迟，适用于主从网络环境复杂或带宽紧张的场景，如跨机房部署。

# 拓扑
Redis 的复制拓扑结构可以支持单层或多层复制关系，根据拓扑复杂性可以分为以下三种：一主一从、一主多从、树状主从结构：
1. 一主一从结构：最简单的复制拓扑结构，用于主节点出现宕机时从节点提供故障转移支持；
2. 一主多从结构（又称为星形拓扑结构）：一主多从结构使得应用端可以利用多个从节点实现读写分离。对于读占比较大的场景，可以把读命令发送到从节点来分担主节点压力。
3. 树状主从结构（又称为树状拓扑结构）：树状主从结构使得从节点不但可以复制主节点数据，同时可以作为其他从节点的主节点继续向下层复制。通过引入复制中间层，可以有效降低主节点负载和需要传送给从节点的数据量。

# 原理

## 复制过程
在从节点执行 slaveof 命令后，复制过程便开始运作，复制过程大致分为 6 个过程：
1. 保存主节点信息；
2. 从节点内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接；从节点会建立一个 socket 套接字专门用于接受主节点发送的复制命令，如果从节点无法建立连接，定时任务会无限重试直到连接成功或者执行 <code>slaveof no one</code> 取消复制。
3. 发送 ping 命令。连接建立成功后从节点发送 ping 请求进行首次通信。如果发送 ping 命令后，从节点没有收到主节点的 pong 回复或者超时，比如网络超时或者主节点正在阻塞无法响应命令，从节点会断开复制连接，下次定时任务会发起重连。
4. 权限验证。如果主节点设置了 requirepass 参数，则需要密码验证，从节点必须配置 masterauth 参数保证与主节点相同的密码才能通过验证；如果验证失败复制将终止，从节点重新发起复制流程。
5. 同步数据集。主从复制连接正常通信后，对于首次建立复制的场景，主节点会把持有的数据全部发送给从节点，这部分操作是耗时最长的步骤。
6. 命令持续复制。当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来主节点会持续地把写命令发送给从节点，保证主从数据一致性。

## 数据同步
Redis 在 2.8 及以上版本使用 psync 命令完成主从数据同步, 同步过程分为：全量复制和部分复制。
* 全量复制：一般用于初次复制场景，它会把主节点全部数据一次性发送给从节点，当数据量较大时，会对主从节点和网络造成很大的开销。Redis 早期支持的复制功能只有全量复制。
* 部分复制：用于处理在主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据给从节点。因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。

psync 命令运行需要以下组件支持：
1. 主从节点各自复制偏移量: 参与复制的主从节点都会维护自身复制偏移量。主节点在处理完写入命令后，会把命令的字节长度做累加记录; 从节点每秒钟上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量, 从节点在接收到主节点发送的命令后，也会累加记录自身的偏移量。通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。
2. 主节点复制积压缓冲区: 复制积压缓冲区是保存在主节点上的一个固定长度的队列，默认大小为1MB，当主节点有连接的从节点时被创建，这时主节点响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓冲区
3. 主节点运行id: 每个Redis节点启动后都会动态分配一个40位的十六进制字符串作为运行ID。运行ID的主要作用是用来唯一识别Redis节点，比如从节点保存主节点的运行ID识别自己正在复制的是哪个主节点。
4. psync命令: 从节点使用psync命令完成部分复制和全量复制功能，命令格式：<code>psync {runId} {offset}</code>，参数含义如下：
* runId：从节点所复制主节点的运行id。
* offset：当前从节点已复制的数据偏移量。

psync 流程说明：
1. 从节点发送 psync 命令给主节点;
2. 主节点根据 psync 参数和自身数据情况决定响应结果：
* 如果回复 <code>+FULLRESYNC {runId} {offset}</code>，那么从节点将触发全量复制流程。
* 如果回复 <code>+CONTINUE</code>，从节点将触发部分复制流程。
* 如果回复 <code>+ERR</code>，说明主节点版本低于 Redis2.8，无法识别 psync 命令，从节点将发送旧版的 sync 命令触发全量复制流程。

## 全量复制
全量复制是 Redis 最早支持的复制方式，也是主从第一次建立复制时必须经历的阶段。触发全量复制的命令是 sync 和 psync。全量复制流程如下：
1. 发送 psync 命令进行数据同步，由于是第一次进行复制，从节点没有复制偏移量和主节点的运行ID，所以发送 <code>psync-1</code>;
2. 主节点根据 <code>psync-1</code> 解析出当前为全量复制，回复 <code>+FULLRESYNC</code> 响应;
3. 从节点接收主节点的响应数据保存运行 ID 和偏移量 offset;
4. 主节点执行 bgsave 保存 RDB 文件到本地;
5. 主节点发送 RDB 文件给从节点，从节点把接收的 RDB 文件保存在本地并直接作为从节点的数据文件;
6. 对于从节点开始接收 RDB 快照到接收完成期间，主节点仍然响应读写命令，因此主节点会把这期间写命令数据保存在复制客户端缓冲区内，当从节点加载完 RDB 文件后，主节点再把缓冲区内的数据发送给从节点，保证主从之间数据一致性。如果主节点创建和传输 RDB 的时间过长，对于高流量写入场景非常容易造成主节点复制客户端缓冲区溢出。默认配置为 <code>client-output-buffer-limit slave 256MB 64MB 60</code>，如果 60 秒内缓冲区消耗持续大于 64MB 或者直接超过 256MB 时，主节点将直接关闭复制客户端连接，造成全量同步失败。
7. 从节点接收完主节点传送来的全部数据后会清空自身旧数据;
8. 从节点清空数据后开始加载 RDB 文件，对于较大的 RDB 文件，这一步操作依然比较耗时，可以通过计算日志之间的时间差来判断加载 RDB 的总耗时;
9. 从节点成功加载完 RDB 后，如果当前节点开启了 AOF 持久化功能，它会立刻做 bgrewriteaof 操作，为了保证全量复制后AOF持久化文件立刻可用。

全量复制是一个非常耗时费力的操作，它的时间开销主要包括：
* 主节点bgsave时间;
* RDB文件网络传输时间;
* 从节点清空数据时间;
* 从节点加载RDB的时间;
* 可能的AOF重写时间;
所以除了第一次复制时采用全量复制在所难免之外，对于其他场景应该规避全量复制的发生。

## 部分复制
部分复制主要是 Redis 针对全量复制的开销过高做出的一种优化措施，使用 <code>psync {runId} {offset}</code> 命令实现。当从节点正在复制主节点时，如果出现网络闪断或者命令丢失等异常情况时，从节点会向主节点要求补发丢失的命令数据，如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点，这样就可以保持主从节点复制的一致性。部分复制的大致流程如下：
1. 当主从节点之间网络出现中断时，如果超过 repl-timeout时间，主节点会认为从节点故障并中断复制连接；
2. 主从连接中断期间主节点依然响应命令，但因复制连接中断命令无法发送给从节点，不过主节点内部存在的复制积压缓冲区，依然可以保存最近一段时间的写命令数据，默认最大缓存 1MB。
3. 当主从节点网络恢复后，从节点会再次连上主节点；
4. 当主从连接恢复后，由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。因此会把它们当作 psync 参数发送给主节点，要求进行部分复制操作；
5. 主节点接到 psync 命令后首先核对参数 runId 是否与自身一致，如果一致，说明之前复制的是当前主节点；之后根据参数 offset 在自身复制积压缓冲区查找，如果偏移量之后的数据存在缓冲区中，则对从节点发送 <code>+CONTINUE</code> 响应，表示可以进行部分复制；
6. 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点，保证主从复制进入正常状态。

## 异步复制
主节点不但负责数据读写，还负责把写命令同步给从节点。写命令的发送过程是异步完成，也就是说主节点自身处理完写命令后直接返回给客户端，并不等待从节点复制完成。主节点复制流程如下：
1. 主节点 6379 接收处理命令；
2. 命令处理完之后返回响应结果；
3. 对于修改命令异步发送给 6380 从节点，从节点在主线程中执行复制的命令。

## 开发与运维中的问题

### 读写分离
对于读占比较高的场景，可以通过把一部分读流量分摊到从节点来减轻主节点压力，同时需要注意永远只对主节点执行写操作。当使用从节点响应读请求时，业务端可能会遇到如下问题：

* **数据延迟**: Redis 复制数据的延迟由于异步复制特性是无法避免的，延迟取决于网络带宽和命令阻塞情况，比如刚在主节点写入数据后立刻在从节点上读取可能获取不到。对于无法容忍大量延迟场景，可以编写外部监控程序监听主从节点的复制偏移量，当延迟较大时触发报警或者通知客户端避免读取延迟过高的从节点。
* **读到过期数据**: 当主节点存储大量设置超时的数据时，如缓存数据，Redis 内部需要维护过期数据删除策略，删除策略主要有两种：惰性删除和定时删除。
惰性删除指主节点每次处理读取命令时，都会检查键是否超时，如果超时则执行删除命令删除键对象，之后删除命令也会异步发送给从节点(需要注意的是为了保证复制的一致性，从节点自身永远不会主动删除超时数据)；定时删除指 Redis 主节点在内部定时任务会循环采样一定数量的键，当发现采样的键过期时执行删除命令，之后再同步给从节点；
* **从节点故障**：对于从节点的故障问题，需要在客户端维护可用从节点列表，当从节点故障时立刻切换到其他从节点或主节点上。这个过程类似上文提到的针对延迟过高的监控处理，需要开发人员改造客户端类库。

### 规避全量复制
以下是需要进行全量复制的场景：
1. 第一次建立复制：由于是第一次建立复制，从节点不包含任何主节点数据，因此必须进行全量复制才能完成数据同步；
2. 节点运行ID不匹配：当主从复制关系建立后，从节点会保存主节点的运行 ID，如果此时主节点因故障重启，那么它的运行 ID 会改变，从节点发现主节点运行 ID 不匹配时，会认为自己复制的是一个新的主节点从而进行全量复制。
3. 复制积压缓冲区不足：当主从节点网络中断后，从节点再次连上主节点时会发送 <code>psync {offset} {runId}</code> 命令请求部分复制，如果请求的偏移量不在主节点的积压缓冲区内，则无法提供给从节点数据，因此部分复制会退化为全量复制。

除此之外，应尽量避免全量复制，采用部分复制。

### 规避复制风暴
复制风暴是指大量从节点对同一主节点或者对同一台机器的多个主节点短时间内发起全量复制的过程。

复制风暴会对发起复制的主节点造成大量开销，导致CPU、内存、带宽消耗，因此应该分析出复制风暴发生的场景，提前采用合理的方式规避。规避方式有如下几个：

1. 单主节点复制风暴：单主节点复制风暴一般发生在主节点挂载多个从节点的场景。当主节点重启恢复后，从节点会发起全量复制流程，这时主节点就会为从节点创建 RDB 快照，如果在快照创建完毕之前，有多个从节点都尝试与主节点进行全量同步，那么其他从节点将共享这份RDB快照。解决方案首先可以减少主节点挂载从节点的数量，或者采用树状复制结构，加入中间层从节点用来保护主节点。
2. 单机器复制风暴：由于 Redis 的单线程架构，通常单台机器会部署多个 Redis 实例。当一台机器上同时部署多个主节点时，如果这台机器出现故障或网络长时间中断，当它重启恢复后，会有大量从节点针对这台机器的主节点进行全量复制，会造成当前机器网络带宽耗尽。避免方法如下：
* 把主节点尽量分散在多台机器上，避免在单台机器上部署过多的主节点;
* 当主节点所在机器故障后提供故障转移机制，避免机器恢复后进行密集的全量复制。

# 参考资料

[Replication](https://redis.io/topics/replication)
